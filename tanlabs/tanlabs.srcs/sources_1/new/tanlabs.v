`timescale 1ns / 1ps

/* Tsinghua Advanced Networking Labs */
/* with Power On Self Test */

module tanlabs
#(
    parameter SIM = 0
)
(
    input wire RST,

    input wire gtrefclk_p,
    input wire gtrefclk_n,

    output wire [15:0] led,

    // SFP:
    // +-+-+
    // |0|2|
    // +-+-+
    // |1|3|
    // +-+-+
    input wire [3:0] sfp_rx_los,
    input wire [3:0] sfp_rx_p,
    input wire [3:0] sfp_rx_n,
    output wire [3:0] sfp_tx_disable,
    output wire [3:0] sfp_tx_p,
    output wire [3:0] sfp_tx_n,
    output wire [7:0] sfp_led,  // 0 1  2 3  4 5  6 7

    // I2C for SFP, unused.
    input wire sfp_sda,
    input wire sfp_scl,

    input wire clk_50M,

    input wire BTN,
    input wire [3:0] touch_btn,
    input wire [15:0] dip_sw,
    output wire [7:0] dpy0,
    output wire [7:0] dpy1,

    // CPLD UART.
    output wire uart_rdn,
    output wire uart_wrn,
    input wire uart_dataready,
    input wire uart_tbre,
    input wire uart_tsre,

    // SRAMs.
    inout wire [31:0] base_ram_data,
    output wire [19:0] base_ram_addr,
    output wire [3:0] base_ram_be_n,
    output wire base_ram_ce_n,
    output wire base_ram_oe_n,
    output wire base_ram_we_n,

    inout wire [31:0] ext_ram_data,
    output wire [19:0] ext_ram_addr,
    output wire [3:0] ext_ram_be_n,
    output wire ext_ram_ce_n,
    output wire ext_ram_oe_n,
    output wire ext_ram_we_n,

    // UART.
    output wire txd,
    input wire rxd,

    // Flash.
    output wire [22:0] flash_a,
    inout wire [15:0] flash_d,
    output wire flash_rp_n,
    output wire flash_vpen,
    output wire flash_ce_n,
    output wire flash_oe_n,
    output wire flash_we_n,
    output wire flash_byte_n,

    // HDMI.
    output wire [2:0] video_red,
    output wire [2:0] video_green,
    output wire [1:0] video_blue,
    output wire video_hsync,
    output wire video_vsync,
    output wire video_clk,
    output wire video_de
);

    localparam DATA_WIDTH = 64;
    localparam ID_WIDTH = 3;

    wire [4:0] debug_ingress_interconnect_ready;
    wire debug_datapath_fifo_ready;
    wire debug_egress_interconnect_ready;

    wire reset_in = RST;
    wire locked;
    wire gtref_clk;  // 125MHz for the PHY/MAC IP core
    wire ref_clk;  // 200MHz for the PHY/MAC IP core
    wire core_clk;  // README: This is for CPU and other components. You can change the frequency
    // by re-customizing the following IP core.
    wire ram_clk;

    clk_wiz_0 clk_wiz_0_i(
        .ref_clk_out(ref_clk),
        .core_clk_out(core_clk),
        .ram_clk_out(ram_clk),
        .reset(1'b0),
        .locked(locked),
        .clk_in1(gtref_clk)
    );

    wire reset_not_sync = reset_in || !locked;  // reset components

    wire mmcm_locked_out;
    wire rxuserclk_out;
    wire rxuserclk2_out;
    wire userclk_out;
    wire userclk2_out;
    wire pma_reset_out;
    wire gt0_pll0outclk_out;
    wire gt0_pll0outrefclk_out;
    wire gt0_pll1outclk_out;
    wire gt0_pll1outrefclk_out;
    wire gt0_pll0lock_out;
    wire gt0_pll0refclklost_out;
    wire gtref_clk_out;
    wire gtref_clk_buf_out;

    assign gtref_clk = gtref_clk_buf_out;
    wire eth_clk = userclk2_out;  // README: This is the main clock for frame processing logic,
    // 125MHz generated by the PHY/MAC IP core. 8 AXI-Streams are in this clock domain.

    wire reset_eth_not_sync = reset_in || !mmcm_locked_out;
    wire reset_eth;
    reset_sync reset_sync_reset_eth(
        .clk(eth_clk),
        .i(reset_eth_not_sync),
        .o(reset_eth)
    );

    wire [7:0] eth_tx8_data [0:3];
    wire eth_tx8_last [0:3];
    wire eth_tx8_ready [0:3];
    wire eth_tx8_user [0:3];
    wire eth_tx8_valid [0:3];

    wire [7:0] eth_rx8_data [0:3];
    wire eth_rx8_last [0:3];
    wire eth_rx8_user [0:3];
    wire eth_rx8_valid [0:3];

    genvar i;
    generate
        if (!SIM)
        begin : phy_mac_ip_cores
            // Instantiate 4 PHY/MAC IP cores.

            assign sfp_tx_disable[0] = 1'b0;
            axi_ethernet_0 axi_ethernet_0_i(
                .mac_irq(),
                .tx_mac_aclk(),
                .rx_mac_aclk(),
                .tx_reset(),
                .rx_reset(),

                .glbl_rst(reset_not_sync),

                .mmcm_locked_out(mmcm_locked_out),
                .rxuserclk_out(rxuserclk_out),
                .rxuserclk2_out(rxuserclk2_out),
                .userclk_out(userclk_out),
                .userclk2_out(userclk2_out),
                .pma_reset_out(pma_reset_out),
                .gt0_pll0outclk_out(gt0_pll0outclk_out),
                .gt0_pll0outrefclk_out(gt0_pll0outrefclk_out),
                .gt0_pll1outclk_out(gt0_pll1outclk_out),
                .gt0_pll1outrefclk_out(gt0_pll1outrefclk_out),
                .gt0_pll0lock_out(gt0_pll0lock_out),
                .gt0_pll0refclklost_out(gt0_pll0refclklost_out),
                .gtref_clk_out(gtref_clk_out),
                .gtref_clk_buf_out(gtref_clk_buf_out),

                .ref_clk(ref_clk),

                .s_axi_lite_resetn(~reset_eth),
                .s_axi_lite_clk(eth_clk),
                .s_axi_araddr(0),
                .s_axi_arready(),
                .s_axi_arvalid(0),
                .s_axi_awaddr(0),
                .s_axi_awready(),
                .s_axi_awvalid(0),
                .s_axi_bready(0),
                .s_axi_bresp(),
                .s_axi_bvalid(),
                .s_axi_rdata(),
                .s_axi_rready(0),
                .s_axi_rresp(),
                .s_axi_rvalid(),
                .s_axi_wdata(0),
                .s_axi_wready(),
                .s_axi_wvalid(0),

                .s_axis_tx_tdata(eth_tx8_data[0]),
                .s_axis_tx_tlast(eth_tx8_last[0]),
                .s_axis_tx_tready(eth_tx8_ready[0]),
                .s_axis_tx_tuser(eth_tx8_user[0]),
                .s_axis_tx_tvalid(eth_tx8_valid[0]),

                .m_axis_rx_tdata(eth_rx8_data[0]),
                .m_axis_rx_tlast(eth_rx8_last[0]),
                .m_axis_rx_tuser(eth_rx8_user[0]),
                .m_axis_rx_tvalid(eth_rx8_valid[0]),

                .s_axis_pause_tdata(0),
                .s_axis_pause_tvalid(0),

                .rx_statistics_statistics_data(),
                .rx_statistics_statistics_valid(),
                .tx_statistics_statistics_data(),
                .tx_statistics_statistics_valid(),

                .tx_ifg_delay(8'h00),
                .status_vector(),
                .signal_detect(~sfp_rx_los[0]),

                .sfp_rxn(sfp_rx_n[0]),
                .sfp_rxp(sfp_rx_p[0]),
                .sfp_txn(sfp_tx_n[0]),
                .sfp_txp(sfp_tx_p[0]),

                .mgt_clk_clk_n(gtrefclk_n),
                .mgt_clk_clk_p(gtrefclk_p)
            );

            for (i = 1; i < 4; i = i + 1)
            begin
                assign sfp_tx_disable[i] = 1'b0;
                axi_ethernet_noshared axi_ethernet_noshared_i(
                    .mac_irq(),
                    .tx_mac_aclk(),
                    .rx_mac_aclk(),
                    .tx_reset(),
                    .rx_reset(),

                    .glbl_rst(reset_not_sync),

                    .mmcm_locked(mmcm_locked_out),
                    .mmcm_reset_out(),
                    .rxuserclk(rxuserclk_out),
                    .rxuserclk2(rxuserclk2_out),
                    .userclk(userclk_out),
                    .userclk2(userclk2_out),
                    .pma_reset(pma_reset_out),
                    .rxoutclk(),
                    .txoutclk(),
                    .gt0_pll0outclk_in(gt0_pll0outclk_out),
                    .gt0_pll0outrefclk_in(gt0_pll0outrefclk_out),
                    .gt0_pll1outclk_in(gt0_pll1outclk_out),
                    .gt0_pll1outrefclk_in(gt0_pll1outrefclk_out),
                    .gt0_pll0lock_in(gt0_pll0lock_out),
                    .gt0_pll0refclklost_in(gt0_pll0refclklost_out),
                    .gt0_pll0reset_out(),
                    .gtref_clk(gtref_clk_out),
                    .gtref_clk_buf(gtref_clk_buf_out),

                    .ref_clk(ref_clk),

                    .s_axi_lite_resetn(~reset_eth),
                    .s_axi_lite_clk(eth_clk),
                    .s_axi_araddr(0),
                    .s_axi_arready(),
                    .s_axi_arvalid(0),
                    .s_axi_awaddr(0),
                    .s_axi_awready(),
                    .s_axi_awvalid(0),
                    .s_axi_bready(0),
                    .s_axi_bresp(),
                    .s_axi_bvalid(),
                    .s_axi_rdata(),
                    .s_axi_rready(0),
                    .s_axi_rresp(),
                    .s_axi_rvalid(),
                    .s_axi_wdata(0),
                    .s_axi_wready(),
                    .s_axi_wvalid(0),

                    .s_axis_tx_tdata(eth_tx8_data[i]),
                    .s_axis_tx_tlast(eth_tx8_last[i]),
                    .s_axis_tx_tready(eth_tx8_ready[i]),
                    .s_axis_tx_tuser(eth_tx8_user[i]),
                    .s_axis_tx_tvalid(eth_tx8_valid[i]),

                    .m_axis_rx_tdata(eth_rx8_data[i]),
                    .m_axis_rx_tlast(eth_rx8_last[i]),
                    .m_axis_rx_tuser(eth_rx8_user[i]),
                    .m_axis_rx_tvalid(eth_rx8_valid[i]),

                    .s_axis_pause_tdata(0),
                    .s_axis_pause_tvalid(0),

                    .rx_statistics_statistics_data(),
                    .rx_statistics_statistics_valid(),
                    .tx_statistics_statistics_data(),
                    .tx_statistics_statistics_valid(),

                    .tx_ifg_delay(8'h00),
                    .status_vector(),
                    .signal_detect(~sfp_rx_los[i]),

                    .sfp_rxn(sfp_rx_n[i]),
                    .sfp_rxp(sfp_rx_p[i]),
                    .sfp_txn(sfp_tx_n[i]),
                    .sfp_txp(sfp_tx_p[i])
                );
            end
        end
        else
        begin : axis_models
            // For simulation.
            assign gtref_clk_buf_out = gtrefclk_p;
            assign userclk2_out = gtrefclk_p;
            assign mmcm_locked_out = 1'b1;

            assign sfp_tx_disable = 0;
            assign sfp_tx_p = 0;
            assign sfp_tx_n = 0;

            wire [DATA_WIDTH - 1:0] in_data;
            wire [DATA_WIDTH / 8 - 1:0] in_keep;
            wire in_last;
            wire [DATA_WIDTH / 8 - 1:0] in_user;
            wire [ID_WIDTH - 1:0] in_id;
            wire in_valid;
            wire in_ready;

            axis_model axis_model_i(
                .clk(eth_clk),
                .reset(reset_eth),

                .m_data(in_data),
                .m_keep(in_keep),
                .m_last(in_last),
                .m_user(in_user),
                .m_id(in_id),
                .m_valid(in_valid),
                .m_ready(in_ready)
            );

            wire [DATA_WIDTH - 1:0] sim_tx_data [0:3];
            wire [DATA_WIDTH / 8 - 1:0] sim_tx_keep [0:3];
            wire sim_tx_last [0:3];
            wire sim_tx_ready [0:3];
            wire [DATA_WIDTH / 8 - 1:0] sim_tx_user [0:3];
            wire sim_tx_valid [0:3];

            axis_interconnect_egress axis_interconnect_sim_in_i(
                .ACLK(eth_clk),
                .ARESETN(~reset_eth),

                .S00_AXIS_ACLK(eth_clk),
                .S00_AXIS_ARESETN(~reset_eth),
                .S00_AXIS_TVALID(in_valid),
                .S00_AXIS_TREADY(in_ready),
                .S00_AXIS_TDATA(in_data),
                .S00_AXIS_TKEEP(in_keep),
                .S00_AXIS_TLAST(in_last),
                .S00_AXIS_TDEST(in_id),
                .S00_AXIS_TUSER(in_user),

                .M00_AXIS_ACLK(eth_clk),
                .M00_AXIS_ARESETN(~reset_eth),
                .M00_AXIS_TVALID(sim_tx_valid[0]),
                .M00_AXIS_TREADY(sim_tx_ready[0]),
                .M00_AXIS_TDATA(sim_tx_data[0]),
                .M00_AXIS_TKEEP(sim_tx_keep[0]),
                .M00_AXIS_TLAST(sim_tx_last[0]),
                .M00_AXIS_TDEST(),
                .M00_AXIS_TUSER(sim_tx_user[0]),

                .M01_AXIS_ACLK(eth_clk),
                .M01_AXIS_ARESETN(~reset_eth),
                .M01_AXIS_TVALID(sim_tx_valid[1]),
                .M01_AXIS_TREADY(sim_tx_ready[1]),
                .M01_AXIS_TDATA(sim_tx_data[1]),
                .M01_AXIS_TKEEP(sim_tx_keep[1]),
                .M01_AXIS_TLAST(sim_tx_last[1]),
                .M01_AXIS_TDEST(),
                .M01_AXIS_TUSER(sim_tx_user[1]),

                .M02_AXIS_ACLK(eth_clk),
                .M02_AXIS_ARESETN(~reset_eth),
                .M02_AXIS_TVALID(sim_tx_valid[2]),
                .M02_AXIS_TREADY(sim_tx_ready[2]),
                .M02_AXIS_TDATA(sim_tx_data[2]),
                .M02_AXIS_TKEEP(sim_tx_keep[2]),
                .M02_AXIS_TLAST(sim_tx_last[2]),
                .M02_AXIS_TDEST(),
                .M02_AXIS_TUSER(sim_tx_user[2]),

                .M03_AXIS_ACLK(eth_clk),
                .M03_AXIS_ARESETN(~reset_eth),
                .M03_AXIS_TVALID(sim_tx_valid[3]),
                .M03_AXIS_TREADY(sim_tx_ready[3]),
                .M03_AXIS_TDATA(sim_tx_data[3]),
                .M03_AXIS_TKEEP(sim_tx_keep[3]),
                .M03_AXIS_TLAST(sim_tx_last[3]),
                .M03_AXIS_TDEST(),
                .M03_AXIS_TUSER(sim_tx_user[3]),

                .M04_AXIS_ACLK(eth_clk),
                .M04_AXIS_ARESETN(~reset_eth),
                .M04_AXIS_TVALID(),
                .M04_AXIS_TREADY(1'b1),
                .M04_AXIS_TDATA(),
                .M04_AXIS_TKEEP(),
                .M04_AXIS_TLAST(),
                .M04_AXIS_TDEST(),
                .M04_AXIS_TUSER(),

                .S00_DECODE_ERR()
            );

            for (i = 0; i < 4; i = i + 1)
            begin
                axis_dwidth_converter_64_8 axis_dwidth_converter_64_8_i(
                    .aclk(eth_clk),
                    .aresetn(~reset_eth),

                    .s_axis_tvalid(sim_tx_valid[i]),
                    .s_axis_tready(sim_tx_ready[i]),
                    .s_axis_tdata(sim_tx_data[i]),
                    .s_axis_tkeep(sim_tx_keep[i]),
                    .s_axis_tlast(sim_tx_last[i]),
                    .s_axis_tuser(sim_tx_user[i]),

                    .m_axis_tvalid(eth_rx8_valid[i]),
                    .m_axis_tready(debug_ingress_interconnect_ready[i]),  // FIXME
                    .m_axis_tdata(eth_rx8_data[i]),
                    .m_axis_tkeep(),
                    .m_axis_tlast(eth_rx8_last[i]),
                    .m_axis_tuser(eth_rx8_user[i])
                );
            end

            wire [DATA_WIDTH - 1:0] out_data;
            wire [DATA_WIDTH / 8 - 1:0] out_keep;
            wire out_last;
            wire [DATA_WIDTH / 8 - 1:0] out_user;
            wire [ID_WIDTH - 1:0] out_dest;
            wire out_valid;
            wire out_ready;

            axis_interconnect_ingress axis_interconnect_sim_out_i(
                .ACLK(eth_clk),
                .ARESETN(~reset_eth),

                .S00_AXIS_ACLK(eth_clk),
                .S00_AXIS_ARESETN(~reset_eth),
                .S00_AXIS_TVALID(eth_tx8_valid[0]),
                .S00_AXIS_TREADY(eth_tx8_ready[0]),
                .S00_AXIS_TDATA(eth_tx8_data[0]),
                .S00_AXIS_TKEEP(1'b1),
                .S00_AXIS_TLAST(eth_tx8_last[0]),
                .S00_AXIS_TID(3'd0),
                .S00_AXIS_TUSER(eth_tx8_user[0]),

                .S01_AXIS_ACLK(eth_clk),
                .S01_AXIS_ARESETN(~reset_eth),
                .S01_AXIS_TVALID(eth_tx8_valid[1]),
                .S01_AXIS_TREADY(eth_tx8_ready[1]),
                .S01_AXIS_TDATA(eth_tx8_data[1]),
                .S01_AXIS_TKEEP(1'b1),
                .S01_AXIS_TLAST(eth_tx8_last[1]),
                .S01_AXIS_TID(3'd1),
                .S01_AXIS_TUSER(eth_tx8_user[1]),

                .S02_AXIS_ACLK(eth_clk),
                .S02_AXIS_ARESETN(~reset_eth),
                .S02_AXIS_TVALID(eth_tx8_valid[2]),
                .S02_AXIS_TREADY(eth_tx8_ready[2]),
                .S02_AXIS_TDATA(eth_tx8_data[2]),
                .S02_AXIS_TKEEP(1'b1),
                .S02_AXIS_TLAST(eth_tx8_last[2]),
                .S02_AXIS_TID(3'd2),
                .S02_AXIS_TUSER(eth_tx8_user[2]),

                .S03_AXIS_ACLK(eth_clk),
                .S03_AXIS_ARESETN(~reset_eth),
                .S03_AXIS_TVALID(eth_tx8_valid[3]),
                .S03_AXIS_TREADY(eth_tx8_ready[3]),
                .S03_AXIS_TDATA(eth_tx8_data[3]),
                .S03_AXIS_TKEEP(1'b1),
                .S03_AXIS_TLAST(eth_tx8_last[3]),
                .S03_AXIS_TID(3'd3),
                .S03_AXIS_TUSER(eth_tx8_user[3]),

                .S04_AXIS_ACLK(eth_clk),
                .S04_AXIS_ARESETN(~reset_eth),
                .S04_AXIS_TVALID(1'b0),
                .S04_AXIS_TREADY(),
                .S04_AXIS_TDATA(0),
                .S04_AXIS_TKEEP(1'b1),
                .S04_AXIS_TLAST(1'b0),
                .S04_AXIS_TID(3'd4),
                .S04_AXIS_TUSER(1'b0),

                .M00_AXIS_ACLK(eth_clk),
                .M00_AXIS_ARESETN(~reset_eth),
                .M00_AXIS_TVALID(out_valid),
                .M00_AXIS_TREADY(out_ready),
                .M00_AXIS_TDATA(out_data),
                .M00_AXIS_TKEEP(out_keep),
                .M00_AXIS_TLAST(out_last),
                .M00_AXIS_TID(out_dest),
                .M00_AXIS_TUSER(out_user),

                .S00_ARB_REQ_SUPPRESS(0),
                .S01_ARB_REQ_SUPPRESS(0),
                .S02_ARB_REQ_SUPPRESS(0),
                .S03_ARB_REQ_SUPPRESS(0),
                .S04_ARB_REQ_SUPPRESS(0),

                .S00_FIFO_DATA_COUNT(),
                .S01_FIFO_DATA_COUNT(),
                .S02_FIFO_DATA_COUNT(),
                .S03_FIFO_DATA_COUNT(),
                .S04_FIFO_DATA_COUNT()
            );

            axis_receiver axis_receiver_i(
                .clk(eth_clk),
                .reset(reset_eth),

                .s_data(out_data),
                .s_keep(out_keep),
                .s_last(out_last),
                .s_user(out_user),
                .s_dest(out_dest),
                .s_valid(out_valid),
                .s_ready(out_ready)
            );
        end
    endgenerate

    wire [7:0] out_led;
    led_delayer led_delayer_i(
        .clk(eth_clk),
        .reset(reset_eth),
        .in_led({eth_tx8_valid[3] & eth_tx8_ready[3], ~sfp_rx_los[3],
                 eth_tx8_valid[2] & eth_tx8_ready[2], ~sfp_rx_los[2],
                 eth_tx8_valid[1] & eth_tx8_ready[1], ~sfp_rx_los[1],
                 eth_tx8_valid[0] & eth_tx8_ready[0], ~sfp_rx_los[0]}),
        .out_led(out_led)
    );
    assign sfp_led = out_led;

    generate
        for (i = 0; i < 4; i = i + 1)
        begin
            wire [511:0] data;
            case (i)
            0: assign data = 512'h41414141414141414141414141414141414102020202ffffffffffff0101010122222222222201000406000801000608222222222222ffffffffffff;
            1: assign data = 512'h42424242424242424242424242424242424242424242424242420202020201010101ca740040000001002e0000450008222222222222ffffffffffff;
            2: assign data = 512'h434343434343222200000000000000000000b80d0120111100000000000000000000b80d01204000060000000060dd86222222222222ffffffffffff;
            3: assign data = 512'h444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444440000222222222222ffffffffffff;
            endcase

            axis_dwidth_converter_512_8 axis_dwidth_converter_512_8_i(
                .aclk(eth_clk),
                .aresetn(~reset_eth),

                .s_axis_tvalid(1'b1),
                .s_axis_tready(),
                .s_axis_tdata(data),
                .s_axis_tkeep(64'h0fffffffffffffff),
                .s_axis_tlast(1'b1),
                .s_axis_tuser(64'd0),

                .m_axis_tvalid(eth_tx8_valid[i]),
                .m_axis_tready(eth_tx8_ready[i]),
                .m_axis_tdata(eth_tx8_data[i]),
                .m_axis_tkeep(),
                .m_axis_tlast(eth_tx8_last[i]),
                .m_axis_tuser(eth_tx8_user[i])
            );
        end
    endgenerate

    led_delayer led_delayer_debug_i1(
        .clk(eth_clk),
        .reset(reset_eth),
        .in_led({eth_rx8_user[3], eth_rx8_valid[3],
                 eth_rx8_user[2], eth_rx8_valid[2],
                 eth_rx8_user[1], eth_rx8_valid[1],
                 eth_rx8_user[0], eth_rx8_valid[0]}),
        .out_led(led[7:0])
    );

    // README: You may use this to reset your CPU.
    wire reset_core;
    reset_sync reset_sync_reset_core(
        .clk(core_clk),
        .i(reset_not_sync),
        .o(reset_core)
    );

    // README: Your code here.

    wire reset_50M;
    reset_sync reset_sync_reset_50m(
        .clk(clk_50M),
        .i(reset_not_sync),
        .o(reset_50M)
    );

    // Blink Test.
    reg [7:0] blink;
    integer counter;
    always @ (posedge clk_50M or posedge reset_50M)
    begin
        if (reset_50M)
        begin
            blink <= 8'h55;
            counter <= 0;
        end
        else
        begin
            if (counter == 25000000 - 1)
            begin
                counter <= 0;
                blink <= {blink[6:0], blink[7]};
            end
            else
            begin
                counter <= counter + 1;
            end 
        end
    end
    assign led[15:8] = blink;

    // HDMI Test. 800x600 @ 75Hz, pixel clock 50MHz
    wire [11:0] hdata;
    assign video_red = hdata < 266 ? 3'b111 : 0;
    assign video_green = hdata < 532 && hdata >= 266 ? 3'b111 : 0;
    assign video_blue = hdata >= 532 ? 2'b11 : 0;
    assign video_clk = clk_50M;
    vga #(12, 800, 856, 976, 1040, 600, 637, 643, 666, 1, 1) vga800x600at75 (
        .clk(clk_50M), 
        .hdata(hdata),
        .vdata(),
        .hsync(video_hsync),
        .vsync(video_vsync),
        .data_enable(video_de)
    );

    // Counter Test.
    reg [3:0] number_counter;
    SEG7_LUT segH(.oSEG1(dpy1), .iDIG(number_counter));
    always @ (posedge BTN or posedge RST)
    begin
        if (RST)
        begin
            number_counter <= 0;
        end
        else
        begin
            number_counter <= number_counter + 1;
        end
    end

    // SRAM Test.
    wire reset_ram;
    reset_sync reset_sync_reset_ram(
        .clk(ram_clk),
        .i(reset_not_sync),
        .o(reset_ram)
    );

    localparam RAM_MAX_ADDR = 21'h1fffff;

    reg last_valid;
    reg [20:0] ram_addr, last_addr;
    reg [31:0] ram_data_o, last_data;
    reg ram_we;
    wire [3:0] ram_be = 4'b1111;

    assign base_ram_addr = ram_addr[19:0];
    assign ext_ram_addr = ram_addr[19:0];
    wire [31:0] ram_data_i = ram_addr[20] ? ext_ram_data : base_ram_data;
    assign base_ram_data = ram_we ? ram_data_o : 'bz;
    assign ext_ram_data = ram_we ? ram_data_o : 'bz;

    assign uart_rdn = 1'b1;
    assign uart_wrn = 1'b1;
    assign base_ram_be_n = ~ram_be;
    assign base_ram_ce_n = ram_addr[20];
    assign base_ram_oe_n = ram_we;
    assign base_ram_we_n = ~ram_we | ram_clk;  // Magic!!!
    assign ext_ram_be_n = ~ram_be;
    assign ext_ram_ce_n = ~ram_addr[20];
    assign ext_ram_oe_n = ram_we;
    assign ext_ram_we_n = ~ram_we | ram_clk;  // Magic!!!

    localparam ST_WRITE = 1;
    localparam ST_START_READ = 2;
    localparam ST_READ_CHECK = 3;
    localparam ST_NEXT_PATTERN = 4;
    localparam ST_DONE = 5;
    localparam ST_ERROR = 6;

    integer state;

    reg [3:0] ram_info;
    SEG7_LUT segL(.oSEG1(dpy0), .iDIG(ram_info));

    always @ (*)
    begin
        ram_info = state;
    end

    localparam PATT_0 = 0;
    localparam PATT_5 = 1;
    localparam PATT_A = 2;
    localparam PATT_F = 3;
    localparam PATT_ADDR = 4;

    integer pattern_state;
    reg [31:0] pattern;
    reg [20:0] pattern_addr;
    always @ (*)
    begin
        pattern_addr = state == ST_WRITE ? ram_addr + 1 : last_addr;
        case (pattern_state)
        PATT_0: pattern = 32'h00000000;
        PATT_5: pattern = 32'h55555555;
        PATT_A: pattern = 32'hAAAAAAAA;
        PATT_F: pattern = 32'hFFFFFFFF;
        default: pattern = {pattern_addr[10:0], pattern_addr};
        endcase
    end

    always @ (posedge ram_clk or posedge reset_ram)
    begin
        if (reset_ram)
        begin
            state <= ST_WRITE;
            pattern_state <= PATT_0;
            ram_addr <= RAM_MAX_ADDR;
            ram_data_o <= 0;
            ram_we <= 1'b0;
            last_valid <= 1'b0;
            last_addr <= 0;
            last_data <= 0;
        end
        else
        begin
            case (state)
            ST_WRITE:
            begin
                if (ram_addr + 1 == RAM_MAX_ADDR)
                begin
                    state <= ST_START_READ;
                end
                ram_we <= 1'b1;
                ram_data_o <= pattern;
                ram_addr <= ram_addr + 1;
            end
            ST_START_READ:
            begin
                ram_we <= 1'b0;
                ram_addr <= 0;
                last_valid <= 1'b0;
                state <= ST_READ_CHECK;
            end
            ST_READ_CHECK:
            begin
                if (last_valid && last_data != pattern)
                begin
                    state <= ST_ERROR;
                end
                else if (last_valid && last_addr == RAM_MAX_ADDR)
                begin
                    state <= ST_NEXT_PATTERN;
                end
                else
                begin
                    last_valid <= 1'b1;
                    last_addr <= ram_addr;
                    last_data <= ram_data_i;
                    ram_addr <= ram_addr + 1;
                end
            end
            ST_NEXT_PATTERN:
            begin
                state <= ST_WRITE;
                ram_addr <= RAM_MAX_ADDR;
                case (pattern_state)
                PATT_0: pattern_state <= PATT_5;
                PATT_5: pattern_state <= PATT_A;
                PATT_A: pattern_state <= PATT_F;
                PATT_F: pattern_state <= PATT_ADDR;
                PATT_ADDR: pattern_state <= PATT_0;
                /*begin
                    state <= ST_DONE;
                end*/
                default: pattern_state <= PATT_0;
                endcase
            end
            ST_DONE:
            begin
                
            end
            ST_ERROR:
            begin
                
            end
            default:
            begin
                state <= ST_WRITE;
                ram_addr <= RAM_MAX_ADDR;
            end
            endcase
        end
    end
endmodule
